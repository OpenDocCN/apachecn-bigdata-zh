# 预测模型

在这一章中，我们将看看什么是预测性建模，以及它如何使用统计数据来预测现有数据的结果。 为了更好地理解概念，我们将介绍真实世界的示例。 我们将了解回归分析的含义，并详细分析它的一些形式。 我们还将看一个为我们预测汽车价格的例子。

以下是我们将在本章中介绍的主题：

*   线性回归及其在 Python 中的实现
*   多项式回归及其应用和实例
*   多元回归及其在 Python 中的实现
*   我们将使用 Python 构建一个预测汽车价格的示例
*   多层次模型的概念及需要了解的几个问题

# 线性回归

让我们来谈谈回归分析，这是数据科学和统计学中非常流行的话题。 这一切都是关于尝试拟合一条曲线或某种函数，以适应一组观测，然后使用该函数来预测你还没有看到的新值。 这就是线性回归的全部内容！

因此，线性回归就是将一条直线与一组观测数据进行拟合。 例如，假设我测量了一群人，我测量这些人的两个特征是他们的体重和身高：

![](Images/0c9e8d83-c2cb-419a-a681-48b1790465ed.png)

我在*x*轴上显示体重，在*y*轴上显示身高，我可以画出所有这些数据点，比如人们的体重与他们的身高，我可以说，“嗯，这看起来像是线性关系，不是吗？也许我可以用一条直线来预测新的值”，这就是线性回归所做的。 在本例中，我最终得到坡度为 0.6 时，定义了一条直线的*y*截距为 130.2(直线的方程式为*y=mx+b*，其中 m 是斜率，b 是*y*截距)。 给定一个斜率和一个*y*截距，这符合我拥有的最好的数据，我可以用这条线来预测新值。

你可以看到，我观察到的体重只上升到 100 公斤的人身上。 如果我有一个体重 120 公斤的人呢？ 嗯，我可以用这条线来计算出，根据之前的数据，体重 120 公斤的人的身高是多少。

我不知道他们为什么叫它倒退。 回归在某种程度上意味着你在做一些倒退的事情。 我猜你可以这样想，你正在创建一条直线，根据你过去的观察结果预测新的价值，时间倒过来，但这看起来有点牵强。 坦率地说，这只是一个令人困惑的术语，也是我们用非常花哨的术语用非常简单的概念来模糊我们所做的事情的一种方式。 它所要做的就是将一条直线拟合到一组数据点上。

# 普通最小二乘法

线性回归是如何工作的？ 在内部，它使用一种叫做普通最小二乘的技术，也被称为 OLS。 你可能也会看到这个词被抛来抛去。 它的工作方式是试图最小化每个点和直线之间的平方误差，其中误差就是每个点和直线之间的距离。

所以，我们把所有这些误差的平方加起来，这听起来很像我们计算方差的时候，对吧，除了它不是相对于平均值，而是相对于我们定义的直线。 我们可以从这条线测量数据点的方差，通过最小化方差，我们可以找到最适合它的线：

![](Images/4afbc931-a14b-4756-99f7-936312f2fd71.png)

现在你再也不用自己费力地去做了，但是如果你出于某种原因不得不这么做，或者如果你只是好奇引擎盖下面发生了什么，我现在将为你描述整个算法，以及你将如何实际去计算斜率和*y*-如果有一天你需要的话，可以用一种艰难的方式截取你自己。 这真的没那么复杂。

还记得直线的斜率截距方程吗？ 它是*y=mx+c*。 斜率就是两个变量之间的相关性乘以*Y*中的标准差除以*X*中的标准差。 标准差自然而然地进入了数学，这看起来可能有点奇怪，但请记住，相关性也包含了标准差，所以你必须重新引入这个术语也就不足为奇了。

然后，截距可以计算为*Y*减去斜率乘以*X*的平均值。 同样，尽管这并不困难，但 Python 将为您完成所有工作，但重点是这些都不是复杂的操作。 它们实际上可以非常高效地完成。

记住，最小二乘最小化了从每个点到直线的误差平方和。 考虑线性回归的另一种方式是，您定义了一条表示观察线的最大可能性的直线；也就是说，对于给定的*x*值，*y*值是某个值的最大概率。

人们有时把线性回归称为最大似然估计，这只是人们给一些非常简单的东西起了个花哨的名字的另一个例子，所以如果你听到有人谈论最大似然估计，他们实际上是在谈论回归。 他们只是想让自己听起来很聪明。 但现在你也知道这个词了，所以你听起来也很聪明。

# 梯度下降技术

进行线性回归的方法不止一种。 我们说过普通的最小二乘法是一种将直线拟合到一组数据的简单方法，但也有其他技术，梯度下降是其中之一，它在三维数据中效果最好。 因此，它试图为您跟踪数据的等高线。 它非常奇特，显然在计算上有点昂贵，但如果您想要将其与普通的最小二乘法进行比较，Python 确实会让您很容易地尝试它。

Using the gradient descent technique can make sense when dealing with 3D data.

通常情况下，最小二乘法是进行线性回归的完美选择，而且它总是合法的，但如果你真的遇到了梯度下降，你就会知道这只是线性回归的另一种方式，通常在高维数据中也会出现这种情况。

# 决定系数或 r 平方

那么我怎么知道我的回归有多好呢？ 我的线条与我的数据的匹配程度如何？ 这就是 r 平方的用武之地，r 平方也被称为决定系数。 再说一次，那些想要听起来聪明的人可能会这么说，但通常它被称为 r 平方。

它是模型捕获的 Y 总变化量的一部分。 那么，你的线条跟得上正在发生的变化有多好呢？ 我们在你们这条线的两边得到的差异是相等的还是不相等的？ 这就是 r-平方所测量的。

# 计算 r 平方

要实际计算该值，请用 1 减去误差平方和与平均值的平方差之和：

![](Images/7e97b7c8-9a8b-4799-bc49-c804617cc0aa.png)

所以，这并不是很难计算，但是同样，Python 会给你一些函数来帮你计算，所以你永远不需要自己去做那个数学运算了。

# 解释 r 平方

对于 r 平方，你会得到一个从 0 到 1 的值。现在 0 表示你的适合度很差。 它不会捕获数据中的任何差异。 而 1 是一个完美的匹配，其中数据中的所有方差都被这条线捕获，并且您在直线两边看到的所有方差在这种情况下都应该是相同的。 所以 0 是坏的，1 是好的。 这就是你真正需要知道的一切。 介于两者之间的东西就是介于两者之间的东西。 较低的 r 平方值表示它不适合，较高的 r 平方值表示它很适合。

正如您将在接下来的小节中看到的，进行回归的方法不止一种。 线性回归就是其中之一。 这是一个非常简单的技术，但也有其他的技术，你可以使用 r 平方作为一个定量的衡量一个给定的回归对一组数据点有多好，然后用它来选择最适合你的数据的模型。(=

# 用 Python 计算线性回归和 r 平方

现在让我们玩一下线性回归，实际计算一些线性回归和 r 平方。 我们可以从这里创建一些 Python 代码开始，这些代码生成一些*随机的*数据，这些数据实际上是线性相关的。

在本例中，我将伪造一些有关页面呈现速度和用户购买数量的数据，就像前面的示例一样。 我们将在网站加载所需的时间和人们在该网站上花费的金额之间建立一个线性关系：

```
%matplotlib inlineimport numpy as npfrom pylab import *pageSpeeds = np.random.normal(3.0, 1.0, 1000)purchaseAmount = 100 - (pageSpeeds + np.random.normal(0, 0.1,1000)) * 3scatter(pageSpeeds, purchaseAmount) 

```

我在这里所做的就是做了一个随机的正态页面速度分布，以 3 秒为中心，标准偏差为 1 秒。 我把购买量设为它的线性函数。 所以，我把它设为 100 减去页面速度加上它周围的正态随机分布，乘以 3。如果我们分散它，我们可以看到数据最终是这样的：

![](Images/ec49842b-65b9-442d-9ce4-5659794c8e28.png)

你只需看一眼就可以看到，那里肯定存在线性关系，这是因为我们确实在源数据中硬编码了真正的线性关系。

现在让我们看看我们是否能梳理出这一点，并用普通的最小二乘法找出最佳拟合线。 我们讨论了如何进行普通的最小二乘和线性回归，但您不需要自己做任何计算，因为 SciPy 包有一个可以导入的`stats`包：

```
from scipy import stats      slope, intercept, r_value, p_value, std_err =     stats.linregress(pageSpeeds, purchaseAmount) 

```

您可以从`scipy`导入`stats`，然后只需在您的两个特性上调用`stats.linregress()`即可。 因此，我们有一个页面速度列表(`pageSpeeds`)和一个相应的购买金额列表(`purchaseAmount`)。 `linregress()`函数将返回一系列内容，包括坡度、截距，这是我定义最佳拟合线所需要的。 它还给了我们`r_value`，我们可以从它得到 r-平方来衡量拟合的质量，还有几件事我们稍后会讨论。 目前，我们只需要斜率、截取和`r_value`，所以让我们继续运行它们。 我们将从找到最适合的线性回归开始：

```
r_value ** 2

```

以下是您的输出应该是什么样子：

![](Images/d4cdfbe1-90cf-4adf-8a5c-7b3e986dfc7f.png)

现在我们得到的直线的 r-平方值是 0.99，几乎是 1.0。 这意味着我们真的有很好的拟合，这并不令人惊讶，因为我们确保了这些数据之间存在真正的线性关系。 尽管这条线周围有一些变化，但我们的线捕捉到了这种变化。 我们在这条线的两边都有大致相同的方差，这是一件好事。 它告诉我们，我们确实有一个线性关系，我们的模型很好地符合我们所拥有的数据。

让我们画出这条线：

```
import matplotlib.pyplot as pltdef predict(x):return slope * x + interceptfitLine = predict(pageSpeeds)plt.scatter(pageSpeeds, purchaseAmount)plt.plot(pageSpeeds, fitLine, c='r')plt.show()

```

以下是前面代码的输出：

![](Images/bbdc1831-fa60-406a-b31c-2da0b56d83bb.png)

这一小段代码将创建一个函数，用于在数据旁边绘制最佳拟合直线。 这里有更多的 Matplotlib 魔法在上演。 我们将创建一个`fitLine`列表，我们将使用我们编写的`predict()`函数来获取`pageSpeeds`，也就是我们的*x*轴，并从中创建 Y 函数。 因此，我们将使用上面的`linregress()`调用返回的`slope`次`x`加上`intercept`，而不是对花费金额进行观察，而是找到预测的值，而不是只使用`slope`次`x`加上从上面的`linregress()`调用中返回的`intercept`。 基本上，我们将像以前一样做一个散点图来显示原始数据点，也就是观测值。

然后，我们还将在同一个`pyplot`实例上调用`plot`，使用我们使用返回的直线方程创建的`fitLine`，并将它们全部显示在一起。 当我们这样做时，它看起来如下图所示：

![](Images/101f3d47-4ad7-4857-a725-ee4af55c2d9a.png)

您可以看到，我们的产品线实际上非常适合我们的数据！ 它正好位于中间，所有你需要预测的新值就是这个预测功能。 给定一个新的以前未见过的页面速度，我们可以仅使用斜率乘以页面速度加上拦截来预测所花费的金额。 仅此而已，我认为这很棒！

# 线性回归的活度

现在是把你的手弄脏的时候了。 尝试增加测试数据中的随机变量，看看这是否有影响。 记住，r 平方是拟合的度量，我们捕捉到的方差有多大，所以方差的大小，好的。 你为什么不看看这是否真的有什么不同呢？

这是线性回归，一个非常简单的概念。 我们所做的就是用一条直线来拟合一组观测数据，然后我们就可以用这条直线来预测新值了。 非那样做不行。 但为什么要把自己限制在一条线上呢？ 我们还可以做更复杂的其他类型的回归。 我们接下来将探讨这些问题。

# 多项式回归

我们已经讨论过线性回归，即我们用一条直线来拟合一组观测数据。 我们的下一个主题是多项式回归，那就是使用高阶多项式来拟合你的数据。 因此，有时您的数据可能并不真正适合直线。 这就是多项式回归的用武之地。

多项式回归是回归的更一般情况。 那么，为什么要把自己限制在一条直线上呢？ 也许你的数据实际上没有线性关系，或者可能有某种曲线，对吧？ 这种情况经常发生。

并不是所有的关系都是线性的，但线性回归只是我们可以做的一整类回归的一个例子。 如果你还记得我们最终得到的线性回归线的形式是*y=mx+b*，我们从线性回归分析中得到了 m 和 b 的值，从普通的最小二乘法，或者任何你选择的方法。 这只是一阶或一次多项式。 阶数或阶数就是你们看到的 x 的幂。 这就是一阶多项式。

现在，如果我们愿意，我们也可以使用一个二阶多项式，它看起来像*y=ax^2+bx+c*。 如果我们使用二阶多项式进行回归，我们将得到 a、b 和 c 的值。或者，我们可以使用形式为*ax^3+bx^2+cx+d*的三阶多项式。 阶数越高，可以表示的曲线就越复杂。 所以，你把*x*混合在一起的力量越多，你就能得到越复杂的形状和关系。

但学位越多并不总是越好。 通常情况下，您的数据中有一些自然的关系，实际上并不是那么复杂，如果您发现自己在拟合数据上投入了很大的精力，那么您可能是过度拟合了！

Beware of overfitting!

*   不要使用超过你需要的学位
*   首先可视化您的数据，看看曲线到底有多复杂
*   可视化拟合并检查曲线是否偏离其方式以适应异常值
*   高 r 平方仅仅意味着你的曲线很好地符合你的训练数据；它可能是也可能不是好的预报器。

如果你的数据无处不在，并且有很大的差异，你可以疯狂地创建一条直线，就像上下移动一样，试图尽可能接近地拟合这些数据，但实际上，这并不代表这些数据的内在关系。 它在预测新价值方面做得不好。

所以，总是从可视化数据开始，想想曲线到底需要多复杂。 现在你可以使用 r 平方来衡量你的适合度有多好，但请记住，这只是衡量这条曲线对你的训练数据的拟合程度，也就是你用来实际做出预测的数据。 它不能衡量你准确预测未来的能力。

稍后，我们将讨论一些称为**培训/测试**的防止过度匹配的技术，但现在您只需仔细观察它，以确保您不会过度匹配，并且在某个函数上投入的度数不会超过您需要的程度。 当我们探究一个示例时，这会更有意义，所以让我们接下来来做这件事。

# 用 NumPy 实现多项式回归

幸运的是，NumPy 有一个`polyfit`函数，可以非常容易地使用它并尝试不同的结果，所以让我们来看看。 玩多项式回归的时间到了。 顺便说一句，我真的觉得这很有趣。 看到所有的高中数学真正进入到实际应用中，这是一种很酷的感觉。 去吧，打开`PolynomialRegression.ipynb`，让我们找点乐子。

让我们在我们的页面速度和我们的购买量假数据之间创建一个新的关系，这一次我们将创建一个更复杂的关系，它不是线性的。 我们将使用页面速度，并将其作为购买金额的页面速度除法的函数：

```
%matplotlib inlinefrom pylab import *np.random.seed(2)pageSpeeds = np.random.normal(3.0, 1.0, 1000)purchaseAmount = np.random.normal(50.0, 10.0, 1000) / pageSpeedsscatter(pageSpeeds, purchaseAmount)

```

如果我们做散点图，我们最终会得到以下结果：

![](Images/fc603614-4a38-4c85-9ba9-4110bb47373a.png)

顺便说一句，如果您想知道`np.random.seed`行做什么，它会创建一个随机种子值，这意味着当我们进行后续的随机操作时，它们将是确定性的。 通过这样做，我们可以确保，每次运行这段代码时，我们最终都会得到相同的结果。 这在以后会很重要，因为我会建议你回来，对这些数据尝试不同的拟合，来比较你得到的拟合。 因此，重要的是要从相同的初始点集开始。

你可以看到，这不是一个真正的线性关系。 我们可以试着用一条线来拟合它，很多数据都可以，可能是在图表的右边，但不是那么靠左。 我们真的有更多的指数曲线。

现在碰巧 NumPy 有一个`polyfit()`函数，它允许你对这个数据拟合任何你想要的次数多项式。 例如，我们可以说我们的*x*轴是我们拥有的页面速度(`pageSpeeds`)的数组，而我们的*y*轴是我们拥有的购买金额(`purchaseAmount`)的数组。 然后我们就可以调用`np.polyfit(x, y, 4)`，这意味着我们想要一个四次多项式来拟合这个数据。

```
x = np.array(pageSpeeds)y = np.array(purchaseAmount)p4 = np.poly1d(np.polyfit(x, y, 4))

```

让我们继续运行它。 它运行得相当快，然后我们就可以画出来了。 因此，我们将在这里创建一个小图表，绘制原始点和预测点的散点图。

```
import matplotlib.pyplot as plt      xp = np.linspace(0, 7, 100)plt.scatter(x, y)plt.plot(xp, p4(xp), c='r')plt.show()

```

输出如下图所示：

![](Images/be56a569-0f3e-4921-88d8-bfdfa72c018a.png)

在这一点上，它看起来相当合适。 不过，你要问自己的是，“我是不是太适合了？我的曲线看起来是不是真的要去适应异常值了？” 我发现这并不是真的发生。 我真的看不到有太多疯狂的事情发生。

如果我有一个非常高阶的多项式，它可能会在顶部跳起来捕捉那个异常值，然后向下跳下捕捉那里的异常值，在我们有很多密度的地方变得更稳定，然后它可能会遍及所有地方，试图在最后拟合最后一组异常值。 如果你看到这种胡言乱语，你就知道你的多项式的阶数太多了，次数太多了，你可能应该把它调低，因为虽然它符合你观察到的数据，但对预测你没有看到的数据没有用。

想象一下，我有一条曲线，它向上移动，然后再次向下移动，以拟合异常值。 我对介于两者之间的东西的预测是不准确的。 曲线真的应该在中间。 在本书的后面，我们将讨论检测这种过度贴合的主要方法，但现在，请观察它，并知道我们稍后会更深入地了解它。

# 计算 r 平方误差

现在我们可以测量 r 平方误差了。 通过取`sklearn.metrics`中的`r2_score()`函数中的`y`和预测值(`p4(x)`)，我们可以计算出这一点。

```
from sklearn.metrics import r2_scorer2 = r2_score(y, p4(x))      print r2

```

输出如下：

![](Images/a18ffeef-c620-42d8-8fea-a2e3b60a3e1d.png)

我们的代码将一组观测值与一组预测值进行比较，并只需一行代码即可为您计算 r 平方！ 我们的 r 平方结果是 0.829，这还不算太差。 记住，零是坏的，一是好的。 0.82 太接近 1 了，并不完美，从直觉上讲，这是有道理的。 你可以看到，我们的线在数据的中间部分相当不错，但在最左边就不太好了，在最右边就不太好了。 所以，0.82 听起来是对的。

# 多项式回归的活动性

我建议你把这些东西弄得干干净净。 尝试不同阶的多项式。 回到我们运行`polyfit()`函数的地方，尝试除 4 之外的其他值。你可以使用 1，这将返回线性回归，或者你可以尝试一些非常高的值，比如 8，也许你会开始看到过度拟合。 所以看看这会有什么效果。 你会想要改变这一点的。 例如，让我们来看一个三次多项式。

```
x = np.array(pageSpeeds)y = np.array(purchaseAmount)      p4 = np.poly1d(np.polyfit(x, y, 3))  

```

只要不断点击 Run 来完成每一步，你就可以看到它的效果就像…

![](Images/208e9b74-bc29-443a-91b3-88f04c1deff8.png)

我们的三次多项式肯定不如四次多项式好。 如果你真的测量 r 平方误差，从数量上来说，它实际上会变得更糟；但如果我测量得太高，你可能会开始看到过度拟合。 所以只需要找点乐子，看看不同的值，看看不同阶次的多项式对回归有什么影响。 去弄脏你的手，试着学点什么吧。

这就是多项式回归。 再说一次，你需要确保你在这个问题上投入的学位不会超过你所需要的。 只需使用适当的量即可找到看起来与您的数据直观匹配的内容。 太多可能会导致过合身，而太少可能会导致不合身。 所以现在你可以用你的眼球和 r 平方度量来计算出适合你的数据的度数是多少。 让我们继续前进吧。

# 多元回归与汽车价格预测

那么，如果我们试图预测一些基于多个其他属性的值，会发生什么呢？ 比方说，人们的身高不仅取决于他们的体重，还取决于他们的基因或其他可能影响身高的因素。 这就是多元分析的用武之地。 实际上，您可以构建一次考虑多个因素的回归模型。 使用 Python 实际上很容易做到这一点。

让我们来谈谈多元回归，这有点复杂。 多元回归的想法是这样的：如果有不止一个因素影响你试图预测的事情，那该怎么办？

在前面的示例中，我们查看了线性回归。 例如，我们谈到了根据体重预测人们的身高。 我们认为体重是影响他们身高的唯一因素，但也许还有其他因素。 我们还观察了页面速度对购买量的影响。 也许影响购买量的因素不仅仅是页面速度，我们想知道这些不同的因素是如何结合在一起影响价值的。 这就是多元回归的用武之地。

我们现在要看的例子如下所示。 比方说，你正在试图预测一辆车的售价。 它可能基于这款车的许多不同特征，如车身风格、品牌、里程；谁知道呢，甚至取决于轮胎有多好。 对于预测一辆汽车的价格，其中一些功能将比其他功能更重要，但你想要同时考虑所有这些功能。

因此，我们下一步的方法仍然是使用最小二乘法来拟合模型，以符合您的观测集合。 不同之处在于，对于每个不同的特征，我们都会有一组系数。

例如，我们最终得到的价格模型可能是α的线性关系，某种常数，有点像你的 y-截距，加上里程的系数，加上年龄的系数，再加上它有多少门的一些系数。

![](Images/5e0c70c6-ae2c-4435-92e5-e05b7ba56a28.png)

一旦你从最小二乘分析中得到这些系数，我们就可以利用这些信息来计算出，这些特征对我的模型有多重要。 所以，如果我最终得到了一个非常小的系数，比如门的数量，这意味着门的数量并不那么重要，也许我应该把它从我的模型中完全删除，以保持它的简单性。

这是我真的应该在这本书里更经常地说的话。 您总是想做在数据科学中起作用的最简单的事情。 不要把事情过于复杂化，因为通常简单的模型效果最好。 如果你能找到恰到好处的复杂性，但不能更多，那通常是正确的模型。 不管怎样，这些系数给了你一种方式，“嘿，有些东西比其他的更重要，也许我可以去掉其中的一些因素。”

现在，我们仍然可以使用 r 平方通过多元回归来衡量拟合的质量。 它的工作原理是一样的，尽管在进行多元回归时需要假设的一件事是，这些因素本身并不相互依赖。 这并不总是正确的。 所以有时候你需要把这个小小的警告放在脑后。 例如，在这个模型中，我们将假设里程数和车龄没有关系；但实际上，它们很可能是紧密相关的！ 这是该技术的一个限制，它可能根本不能捕捉到效果。

# 用 Python 实现多元回归

幸运的是，有一个适用于 Python 的`statsmodel`包，这使得执行多元回归变得非常容易。 让我们一头扎进水里，看看它是如何运作的。 让我们使用 Python 进行一些多元回归。 我们将使用凯利蓝皮书中有关汽车价值的真实数据。

```
import pandas as pddf = pd.read_excel('http://cdn.sundog-soft.com/Udemy/DataScience/cars.xls')

```

我们将在这里介绍一个名为`pandas`的新包，它使我们能够非常轻松地处理表格数据。 它可以让我们读入数据表，重新排列它们，修改它们，以不同的方式对它们进行切片和切分。 在未来，我们将会大量使用这一点。

我们将把`pandas`作为`pd`导入，`pd`有一个`read_Excel()`函数，我们可以使用该函数通过 HTTP 从 Web 读取 Microsoft Excel 电子表格。 所以，熊猫在那里的能力相当惊人。

我已经在我自己的域中为您托管了该文件，如果我们运行该文件，它会将其加载到我们称为`df`的`DataFrame`对象中。 现在我可以对这个`DataFrame`调用`head()`，只显示它的前几行：

```
df.head()

```

以下是前面代码的输出：

![](Images/d0288fca-7305-4812-b099-6de8fbea7f8f.png)

实际数据集要大得多。 这只是最初的几个样本。 因此，这是里程，品牌，型号，装饰，类型，车门，巡航，声音和皮革的真实数据。

好的，现在我们将使用`pandas`将其拆分成我们关心的功能。 我们将创建一个模型，试图仅根据里程数、模型和门数来预测价格，而不会根据其他因素来预测价格。

```
import statsmodels.api as smdf['Model_ord'] = pd.Categorical(df.Model).codesX = df[['Mileage', 'Model_ord', 'Doors']]y = df[['Price']]X1 = sm.add_constant(X)est = sm.OLS(y, X1).fit()est.summary() 

```

现在我遇到的问题是，这款车是一个文本，就像别克的 Century 一样，你还记得，当我做这种分析时，所有的东西都需要是一个数字。 在代码中，我使用`pandas`中的这个`Categorical() function`将它在`DataFrame`中看到的型号名称集实际转换为一组数字，即一组代码。 我想说 x 轴上这个模型的输入是里程(`Mileage`)、转换为序数值的模型(`Model_ord`)和门数(`Doors`)。 我试图在 y 轴上预测的是价格(`Price`)。

接下来的两行代码创建了一个我称之为`est`的模型，该模型使用普通的最小二乘法 OLS，并使用我给它的列`Mileage`、`Model_ord`和`Doors`进行拟合。 然后，我可以使用汇总调用打印出我的模型：

![](Images/ffce0020-9e84-4ecd-9a73-ac3008463f3a.png)

你可以在这里看到，r 平方是相当低的。 这不是一个很好的模型，真的，但我们可以深入了解各种误差是什么，有趣的是，最低的标准误差与里程有关。

我以前说过，系数是决定哪些项目重要的一种方式，但只有当你的输入数据被归一化时，这才是正确的。 也就是说，如果所有数据都在 0 到 1 的相同范围内。如果不是，那么这些系数可以某种程度上补偿它所看到的数据的规模。 如果您不是在处理标准化数据(如本例所示)，那么查看标准错误会更有用。 在这种情况下，我们可以看到里程数实际上是这款特殊车型的最大因素。 我们能不能早点弄清楚这一点？ 嗯，我们可以只做一点切片和切丁，以计算出门的数量实际上根本不会对价格产生太大影响。 让我们来运行下面这一小段代码：

```
y.groupby(df.Doors).mean()

```

这里有一点`pandas`语法。 在 Python 中只需一行代码就可以做到这一点，这真是太酷了！ 这将打印出一个新的`DataFrame`，显示给定门数的平均价格：

![](Images/218a51f2-f117-4cdc-b50f-25bd99d8990d.png)

我可以看出，两门车的平均售价实际上比四门车的平均售价要高。 如果说有什么不同的话，那就是门的数量和价格之间存在负相关，这有点令人惊讶。 不过，这只是一个很小的数据集，所以我们当然不能从中读出太多意义。

# 多元回归的活动性

作为一项活动，请在你想要的地方摆弄假的输入数据。 您可以下载数据并摆弄电子表格。 从你的本地硬盘而不是从 HTTP 读取它，看看你能有什么不同。 也许您可以构建一个具有不同行为的数据集，并且具有适合它的更好的模型。 也许您可以更明智地选择一些功能作为您的模型的基础。 所以，你可以随意摆弄它，让我们继续前进。

这就是它：多元分析和它运行的一个例子。 与我们探索的多元分析的概念一样重要的是我们在 Python 笔记本中所做的一些事情。 所以，你可能想要回到那里，研究到底发生了什么。

我们介绍了熊猫以及使用熊猫和 DataFrame 对象的方法。 熊猫是一种非常强大的工具。 我们将在以后的小节中更多地使用它，但请确保您开始注意这些事情，因为这些将是您管理大量数据和组织数据的 Python 技能中的重要技术。

# 多层次模型

现在谈论多层次模型是有意义的。 这绝对是一个很高级的话题，我不打算在这里做太多的细节。 我现在的目标是向你介绍多层次模型的概念，让你了解一些挑战，以及当你把它们放在一起时如何思考它们。 就这样。

多层次模型的概念是在层次结构中的不同层次上发生某些效果。 例如，你的健康。 你的健康可能取决于你的单个细胞的健康程度，而这些细胞可能是它们内部器官健康程度的函数，而你器官的健康可能取决于你整体的健康。 你的健康可能在一定程度上取决于你家人的健康状况和家人给你提供的环境。 而你的家人的健康反过来可能取决于你居住的城市的一些因素，那里有多少犯罪，有多大的压力，有多少污染。 除此之外，这可能取决于我们生活的整个世界的因素。 也许仅仅是世界上医疗技术的状况就是一个因素，对吗？

另一个例子：你的财富。 你赚多少钱？ 嗯，这是你个人努力工作的一个因素，但也是你父母所做工作的一个因素，他们能为你的教育和你成长的环境投资多少钱，反过来，你的祖父母呢？ 他们能够创造什么样的环境，他们能够为你的父母提供什么样的教育，这反过来又影响了他们为你自己的教育和养育提供的资源。

这些都是多层次模型的例子，在这些模型中，存在着在更大范围内彼此影响的层级效果。 现在，多层次模型的挑战是试图弄清楚，“那么，我如何对这些相互依赖关系进行建模？我如何对所有这些不同的影响进行建模，以及它们是如何相互影响的？”

这里的挑战是确定每个级别中实际影响您试图预测的事情的因素。 例如，如果我试图预测 SAT 的整体成绩，我知道这在一定程度上取决于参加考试的个别孩子，但孩子的什么才是重要的呢？ 嗯，可能是遗传因素，可能是他们个人的健康状况，也可能是他们拥有的个人大脑大小。 你可以想出许多影响个人的因素，这些因素可能会影响他们的 SAT 分数。 如果你更上一层楼，看看他们的家庭环境，看看他们的家庭。 他们的家庭有哪些因素可能会影响他们的 SAT 成绩？ 他们能提供多少教育？ 家长真的能在 SAT 考试的题目上辅导孩子吗？ 在第二个层面上，这些都可能是重要的因素。 那他们的邻居呢？ 社区的犯罪率可能很重要。 他们为青少年提供的设施，让他们远离街道，诸如此类的事情。

重点是你想要继续关注这些更高的水平，但在每个水平上确定影响你试图预测的事情的因素。 我可以继续提高他们学校的教师质量，学区的资金，州一级的教育政策。 你可以看到，在不同的水平上有不同的因素，这些因素都在你试图预测的东西中提供信息，其中一些因素可能存在于不止一个水平上。 例如，犯罪率存在于地方和州一级。 当你进行多层次建模时，你需要弄清楚它们之间是如何相互影响的。

正如你可以想象的，这很快就会变得非常困难和非常复杂。 这确实超出了本书或任何数据科学入门书籍的范围。 这可不是件容易的事。 有很多关于它的厚厚的书，你可以写一整本关于它的书，这将是一个非常高级的主题。

那么，为什么我甚至提到了多层次模型呢？ 这是因为我在工作描述中看到，在一些情况下，他们想让你知道一些事情。 我从来没有在实践中使用过它，但我认为从从事数据科学的角度来看，重要的是你至少熟悉这个概念，你知道它的含义和创建多层次模型所涉及的一些挑战。 我希望我已经给了你这些概念。 说完了，我们就可以进入下一节了。

这里有多层次模型的概念。 这是一个非常高级的话题，但你至少需要理解这个概念是什么，而且这个概念本身非常简单。 当你试图做出预测时，你只是在观察不同层次、不同层次的效果。 因此，可能存在相互影响的不同层次的效应，这些不同层次可能也有相互关联的因素。 多层次建模试图考虑所有这些不同的层次结构和因素，以及它们如何相互作用。 请放心，这就是目前您需要知道的全部内容。

# 简略的 / 概括的 / 简易判罪的 / 简易的

在本章中，我们讨论了回归分析，它试图将曲线拟合到一组训练数据，然后使用它来预测新值。 我们看到了它不同的形态。 我们了解了线性回归的概念及其在 Python 中的实现。

我们学习了什么是多项式回归，即使用高次多项式为多维数据创建更好、更复杂的曲线。 我们还看到了它在 Python 中的实现。

然后我们谈到了多元回归，这有点复杂。 我们看到了当有多个因素影响我们预测的数据时，它是如何使用的。 我们看了一个有趣的例子，它使用 Python 和一个非常强大的工具 Pandas 来预测一辆汽车的价格。

最后，我们讨论了多层次模型的概念。 我们了解其中的一些挑战，以及当你把它们放在一起时如何思考它们。 在下一章中，我们将学习一些使用 Python 的机器学习技术。